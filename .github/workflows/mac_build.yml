name: build-macos-app

on:
  push:
    branches:
      - master

jobs:
  build:
    runs-on: macos-latest

    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"
          cache: "pip"

      - name: Install Python dependencies
        env:
          CT_METAL: 1
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip setuptools wheel
          python -m pip install -r requirements.txt
          # Reinstall ctransformers from source for Apple Silicon (Metal)
          python -m pip uninstall -y ctransformers
          python -m pip install --no-binary ctransformers ctransformers

      - name: Build .app with PyInstaller
        run: |
          set -euo pipefail
          pyinstaller forensic_summarizer.spec

      # --- SANITY CHECKS (size + ensure no GGUF bundled) ---
      - name: Sanity check build output (size + gguf)
        run: |
          set -euo pipefail
          APP_PATH="dist/forensic_summarizer.app"

          echo "=== App size ==="
          du -sh "$APP_PATH" || true

          echo "=== File count (app) ==="
          find "$APP_PATH" -type f | wc -l || true

          echo "=== Binary count (.dylib/.so/.bundle) ==="
          find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.bundle" \) | wc -l || true

          echo "=== Search for .gguf inside .app (should be empty) ==="
          find "$APP_PATH" -name "*.gguf" -print || true

          echo "=== App bundle structure (top) ==="
          find "$APP_PATH" -maxdepth 3 -print || true

          echo "=== Contents/MacOS ==="
          ls -la "$APP_PATH/Contents/MacOS" || true

          echo "=== Contents ==="
          ls -la "$APP_PATH/Contents" || true


      # --- SIGNING KEYCHAIN SETUP ---
      - name: Import Developer ID certificate (.p12) into temporary keychain
        env:
          APPLE_CERT_P12_BASE64: ${{ secrets.APPLE_CERT_P12_BASE64 }}
          APPLE_CERT_PASSWORD: ${{ secrets.APPLE_CERT_PASSWORD }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"

          echo "$APPLE_CERT_P12_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Allow codesign/productbuild to access the key
          security import "$RUNNER_TEMP/cert.p12" \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_CERT_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/productbuild

          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Detect signing identity (debug)
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${KEYCHAIN_PATH}"

          echo "=== Available code signing identities in temporary keychain ==="
          security find-identity -p codesigning -v "$KEYCHAIN_PATH" || true

          echo "=== Available certificates in temporary keychain (names) ==="
          security find-certificate -a "$KEYCHAIN_PATH" | grep "labl" || true

          SIGN_IDENTITY="$(security find-identity -p codesigning -v "$KEYCHAIN_PATH" \
            | awk -F\" '/Developer ID Application/ {print $2; exit}')"

          if [ -z "${SIGN_IDENTITY}" ]; then
            echo "ERROR: No 'Developer ID Application' identity found in keychain."
            echo "Most likely the .p12 is not a Developer ID Application cert, or it does not include the private key."
            exit 1
          fi

          echo "SIGN_IDENTITY=$SIGN_IDENTITY" >> "$GITHUB_ENV"
          echo "Using SIGN_IDENTITY=$SIGN_IDENTITY"

      - name: Create entitlements (minimal)
        run: |
          set -euo pipefail
          ENTITLEMENTS_PATH="$RUNNER_TEMP/entitlements.plist"
          cat > "$ENTITLEMENTS_PATH" <<'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
          </dict>
          </plist>
          EOF
          echo "ENTITLEMENTS_PATH=$ENTITLEMENTS_PATH" >> "$GITHUB_ENV"

      - name: Codesign .app (hardened runtime)
        run: |
          set -euo pipefail

          APP_PATH="dist/forensic_summarizer.app"
          SIGN_IDENTITY="${SIGN_IDENTITY}"
          ENTITLEMENTS_PATH="${ENTITLEMENTS_PATH}"

          # Sign embedded frameworks first (if any)
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -type d -name "*.framework" -print0 | while IFS= read -r -d '' fw; do
              codesign --force --options runtime --timestamp --sign "$SIGN_IDENTITY" "$fw"
            done
          fi

          # Sign common binary types inside the bundle
          find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.bundle" \) -print0 | while IFS= read -r -d '' f; do
            codesign --force --options runtime --timestamp --sign "$SIGN_IDENTITY" "$f"
          done

          # Sign main executables (PyInstaller puts them here)
          if [ -d "$APP_PATH/Contents/MacOS" ]; then
            find "$APP_PATH/Contents/MacOS" -type f -print0 | while IFS= read -r -d '' f; do
              codesign --force --options runtime --timestamp --sign "$SIGN_IDENTITY" "$f"
            done
          fi

          # Finally sign the app bundle with entitlements
          codesign --force --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS_PATH" \
            --sign "$SIGN_IDENTITY" \
            "$APP_PATH"

          # Verify signature
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      # --- NOTARIZATION ---
      - name: Create zip for notarization (ditto keepParent)
        run: |
          set -euo pipefail
          APP_PATH="dist/forensic_summarizer.app"
          ditto -c -k --keepParent "$APP_PATH" "dist/forensic_summarizer-notary.zip"

          echo "=== Notary zip size ==="
          du -sh "dist/forensic_summarizer-notary.zip" || true

      - name: Submit to Apple notarization (capture submission id)
        id: notarize_submit
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail

          JSON_OUT="$(xcrun notarytool submit "dist/forensic_summarizer-notary.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --output-format json)"

          echo "$JSON_OUT"

          SUBMISSION_ID="$(echo "$JSON_OUT" | python -c "import sys,json; print(json.load(sys.stdin).get('id',''))")"

          if [ -z "$SUBMISSION_ID" ]; then
            echo "ERROR: Could not read submission id from notarytool output."
            exit 1
          fi

          echo "submission_id=$SUBMISSION_ID" >> "$GITHUB_OUTPUT"
          echo "Notary submission id: $SUBMISSION_ID"

      - name: Wait for notarization (timeout + fetch log on failure)
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          SUBMISSION_ID="${{ steps.notarize_submit.outputs.submission_id }}"

          echo "Waiting for notarization to finish (id=$SUBMISSION_ID)..."

          set +e
          xcrun notarytool wait "$SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --timeout 60m
          RC=$?
          set -e

          if [ $RC -ne 0 ]; then
            echo "Notarization did not complete successfully (exit=$RC). Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" || true
            exit $RC
          fi

          echo "Notarization accepted."

      - name: Staple notarization ticket to .app
        run: |
          set -euo pipefail
          APP_PATH="dist/forensic_summarizer.app"
          xcrun stapler staple "$APP_PATH"
          xcrun stapler validate "$APP_PATH"

      - name: Create final distributable zip (ditto keepParent)
        run: |
          set -euo pipefail
          APP_PATH="dist/forensic_summarizer.app"
          rm -f "dist/forensic_summarizer.app.zip"
          ditto -c -k --keepParent "$APP_PATH" "dist/forensic_summarizer.app.zip"

          echo "=== Final zip size ==="
          du -sh "dist/forensic_summarizer.app.zip" || true

      # --- RELEASE ---
      - name: Create GitHub Release (draft)
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: mac-build-${{ github.run_number }}
          release_name: "macOS build ${{ github.run_number }}"
          draft: true
          prerelease: false

      - name: Upload .app.zip to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: dist/forensic_summarizer.app.zip
          asset_name: forensic_summarizer.app.zip
          asset_content_type: application/zip
